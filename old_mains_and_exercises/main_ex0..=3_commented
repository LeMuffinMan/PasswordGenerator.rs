use std::fs;

fn strength_label(strength: &Strength) -> String {
    match &strength {
        Strength::Weak => "The password strength is weak".to_string(),
        Strength::Medium => "The password strength is medium".to_string(),
        Strength::Strong => "The password strength is strong".to_string(),
    }

}

//Result est un keyword ?
// ici <> permet de renseigner deux potentiels valeurs de retour ? string ou u8 ?
fn read_length_from_file(path: &str) -> Result<u8, String> {

    //ici, si je mettais 
    // - .unwrap() pour gerer l'erreur, et que le fichier est absent : panic -> crash au runtime
    // - .expect("Mon message d'erreur") : meme chose que pour unwrap(), mais je peux
    //debuguer avec le message d'erreur qui s'imprimera
    //de maniere generale, on veut toujours eviter de paniquer
    match fs::read_to_string(path) {
        Ok(length) => {
            match length.trim().parse::<u8>() {
                Ok(value) => Ok(value),
                Err(_) => Err("Error parsing string".to_string()),
            }
        },
        Err(_) => {
            Err("Error reading file".to_string()) //un point virgule ici ou dans d'autres arm de
                                                  //match ne renverrait aucune valeur 
                                                  //Donc : ici on met ni , ni ; et pour les cas
                                                  //precedents de match, chaque expression doit
                                                  //finir par un ,
        },
        //Si read_to_string a reussi, on rentre dans le ok, et on stock la valuer en string
        //retournee par read_to_string
            //Si on a eu une string en retour, on tente de la trim, et de la formater en unsigned
            //int 8
                //un nouveau match pour traiter l'erreur : 
                    //succes : on a un u8 => derniere instruction de la fonction : c'est ce qui est
                    //retourne 
                    //Dans tout autre cas (_) : on renvoie une string d'erreur 
        //dans tout autre cas (_) : on retourne une String d'erreur 
    }
}

//alternative pour eadlenth_form_file : 
//let content = fs:read_to_string(path)?; si erreur, la retourne direct
//let value = content.trim().parse::<u8>?; pareil
//Ok(length) <-- pas de ; pour renvoyer la valeur !
//plus concis

//Retour de fonction Option : si peut renvoyer qqchose ou rien du tout : exemple : chercher une
//valeur dans une liste, renvoyer son index, peut renvoyer un index, ou rien si la valeur n'est
//pasd nas la liste 
//Dans ce cas on aurait un return Some(value) et plus loin, hors du for qui itere : un None tout
//seul
//
//Result en retour de fonction : peut renvoyer Ok(value) ou Err(err)
//Result permet de decrire l'erreur et d'agir en fonction de l'erreur

struct PasswordConfig {
    length: u8,
    lowercase: bool,
    uppercase: bool,
    digit: bool,
    symbol: bool,
}

enum Strength {
    Weak,
    Medium,
    Strong,
}

//impl : methode associee a la struct passwordconfig
impl PasswordConfig {
    fn describe(&self) {
        println!("length = {}", self.length);
        println!("lowercase = {}", self.lowercase);
        println!("uppercase = {}", self.uppercase);
        println!("digit = {}", self.digit);
        println!("symbol = {}", self.symbol);
    }
    //&self : ne modifie pas la struct
    //&mut self : peut modifier la struct
    //pas de self : fonction associee / statique ? (fn name() -> Self)
    //methode qui consomme la struct (fn name (self))
}

fn main() {
    let config = PasswordConfig {
        length: 15,
        lowercase: true,
        uppercase: true,
        digit: true,
        symbol: true,
    };

    config.describe();
    println!("{}", strength_label(&Strength::Strong));
    println!("{}", strength_label(&Strength::Medium));
    println!("{}", strength_label(&Strength::Weak));

    println!("Test with existing and regular config.txt:\n");
    match read_length_from_file("config.txt") {
        Ok(value) => println!("Value read from file : {}", value),
        Err(err) => eprintln!("{}", err),
    }
    println!("--------------------------------------");
    println!("Test with non-existing config.txt:\n");
    match read_length_from_file("") {
        Ok(value) => println!("Value read from file : {}", value),
        Err(err) => eprintln!("{}", err),
    }
    println!("--------------------------------------");
    println!("Test with existing config_letters.txt but with unparsable value inside:\n");
    match read_length_from_file("config_letters.txt") {
        Ok(value) => println!("Value read from file : {}", value),
        Err(err) => eprintln!("{}", err),
    }
}
