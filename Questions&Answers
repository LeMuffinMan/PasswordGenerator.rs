Exercise 1 : Structs and Methods

1. What’s the difference between `&self` and `&mut self` in a method?

&self : the struct associated will not be modified by the method / &mut self : allow to modify the struct
&self is an immutable reference to the instance
&mut self : mutable reference, we can modify fields
self : takes the ownership : the methode will consume the instance 

2. Why use a `struct` instead of a tuple here?

the struct allow to use methods to access and or modify the struct
the tuple must be deconstructed to be displayed and modified

struct allow to name fields.
struct can be used with methods, not tuple

3. What happens if a `struct` field is left uninitialized?

no compilation : all variables of struct must be initialized

Rust requires a full initialization : ensure memory safety
C accepts to compile with uninitializd fields

4. Can a `struct` be made immutable after creation?

Yes, declarating it let config = ... 
the struct content won't be mutable
by exposing pub fields or not providing mutating methods, the immutability would be improved

===================================================================================

Exercise 2 : Enums and match

1. What’s the difference between exhaustive `match` and `if let`?

match has arms that covers all cases, with a default arm _ if needed
if let : target one specific case

2. Why is `match` on an `enum` compile-time safe?

We can cover all cases of the enum with the match, so we don't need any default _ arm

3. How can you add associated data to a variant (payload enums)?

for each member of the enum, indicate in parenthesis the data and its type :

enum MyEnum {
  A (i32),
  B (bool, String),
  C (x: f64),
}

4. What happens if you add a variant to the `enum` but don’t update the `match`?

It would not compile


===================================================================================

Exercise 3 : error handling 

1. Why is `unwrap` risky?

like expect() : could cause the program to panic
expect("Error msg") does the same, but help to debug thanks to the msg

2. What’s the difference between `expect` and a manual `match`?

expect() panic, the match cover all cases and allow to save the error 

3. What exactly does the `?` operator do?

instead of match, allow to save the error without paniquing. Makes the code more concise
it does an "early return" of the error or None

4. When is `Option` preferable over `Result`?

If we iterate on an array, to find a matching value, there could be a return value, or not.
With Option, we can return Some(value_found), OR we can return None if we don't find the value
With result : we can return the value, or a string to describe an error (can we return both ?)
if the fact that we didnt found our value in the array is to consider as an error : use Result, if it's not to consider as an error, use Option

Option does not allowed to have infos on a potential error
Result does 

=================================================================================================================================

Exercice 4 : Collections

1. What’s the difference between `push` and `extend`?

push: add one element at then end of vector
extend: Adds multiple elements (from any iterable) to the end of a vector.

2. Why choose `Vec<char>` instead of `String` for the alphabet?

Vec is usefull to manipulate individual elements. 
String would have been less efficient for manipulation and transformation of charset

3. What are the memory implications of a dynamic `Vec`?

On the heap : at runtime, it can grows capacity if needed
but /!\ : Memory usage is proportional to the number of elements and the element size. With Vec<char>, each char is typically 4 bytes (Rust char is Unicode scalar, not a byte).

4. How can you iterate without taking ownership of the elements?

using reference & :

for char in &charset {
  println!("{}", ch);
}

=======================================================================================

Exercise 5 : Using External Crate

1. What’s the difference between `thread_rng` and `StdRng`?

I ended to use rng because cargo flagged thread_rng as deprecated
thread_rng / rng are built for cryptographym StdRng is not ?
thread_rng / rng does not need a seed.
Stdrng would be usefull if i want the reproductibility of my random, using the seed

2. Why is it important to regularly update the `rand` crate?

To maintain dependances updated
important for cryptography security
benefit the last optimisations
compatibility with other dependances

3. What are the risks of a non-cryptographic random generator?

posibility to find the seed and deduce the password generation logic

4. How do you document the dependency in `Cargo.toml`?

in the .toml, under [dependencies]
crate <version> 

rand "0.9.2"


======================================================================

1. Why use `pub` on some functions/structs?

declaring it as public is struct and fcts can be used outside of the file

2. What’s the difference between `mod` and `use`?

mod indicate the crate to find in the project structure
use indicate the struct or the function to use from the crate

3. How to avoid circular dependencies between modules?

organizing coherently the files 

4. What does `super::` mean in a path?

?

