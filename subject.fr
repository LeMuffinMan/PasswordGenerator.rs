Exercices generated by Chat-GPT5 study, with this prompt built with Claude :

Tu es un mentor Rust expérimenté. Je débute en Rust mais j'ai une solide base en C. Je veux que tu me créés une série d'exercices progressifs menant à la création d'un générateur de mots de passe.

Format demandé pour chaque exercice :

Exercice N : [Titre descriptif]

Objectif : [Description claire de ce qu'on va apprendre]

Énoncé : [Description détaillée de l'exercice à réaliser]

Documentation Rust à consulter :

Chapitre X.Y : [Titre] - [URL vers la doc officielle]

Chapitre X.Z : [Titre] - [URL vers la doc officielle]


Questions sur les notions Rust :

1. [Question sur le concept Rust principal de l'exercice]


2. [Question sur un détail technique important]


3. [Question sur les bonnes pratiques Rust]



Questions de comparaison avec C :

1. [Comment cette fonctionnalité diffère-t-elle de C ?]


2. [Quels avantages/inconvénients par rapport à l'équivalent en C ?]


3. [Pourquoi Rust a-t-il fait ce choix de design différent ?]



Progression souhaitée :

1. Bases : Hello World, variables, types de base


2. Ownership : Propriété, emprunt, durée de vie


3. Structures de contrôle : if/else, loops, match


4. Fonctions : définition, paramètres, valeurs de retour


5. Structures de données : struct, enum, Vec, HashMap


6. Gestion d'erreurs : Result, Option, panic


7. Traits et génériques : définition et utilisation


8. Modules et crates : organisation du code


9. I/O et fichiers : lecture/écriture, arguments ligne de commande


10. Générateur final : assemblage pour créer le générateur de mots de passe



Contraintes importantes :

Chaque exercice doit référencer la documentation officielle Rust (https://doc.rust-lang.org/book/)

Les exercices doivent être pratiques et construire vers l'objectif final

Inclure systématiquement des comparaisons avec C pour leverager mes connaissances existantes

Les questions doivent me faire réfléchir sur les concepts, pas juste recopier

Commencer simple et augmenter progressivement la complexité



Exercice 1 : Premier pas avec Rust – Hello World

Objectif :
Découvrir la structure minimale d’un programme Rust, apprendre à compiler et exécuter du code, et comprendre la fonction main.

Énoncé :

Crée un nouveau projet Rust avec cargo new hello_rust.

Dans le fichier main.rs, écris un programme qui affiche exactement :

Hello, Rust!

Compile avec cargo build et exécute avec cargo run.

Modifie le texte affiché pour inclure ton prénom.


Documentation Rust à consulter :

Chapitre 1.1 : "Installation" – https://doc.rust-lang.org/book/ch01-01-installation.html

Chapitre 1.2 : "Hello, World!" – https://doc.rust-lang.org/book/ch01-02-hello-world.html


Questions sur les notions Rust :

1. Pourquoi la fonction main est-elle spéciale en Rust ?


2. Quelle est la différence entre println! et print! ?


3. Pourquoi println! est-il un macro et non une fonction classique ?



Questions de comparaison avec C :

1. Comment la fonction main en Rust diffère-t-elle de celle en C (signature, retour) ?


2. Quels avantages y a-t-il à utiliser cargo plutôt que gcc pour un projet simple ?


3. Pourquoi Rust impose-t-il une structure stricte de projet dès le départ ?




---

Exercice 2 : Variables et types de base

Objectif :
Apprendre à déclarer des variables, comprendre l’immuabilité par défaut, et manipuler les types simples (i32, f64, bool, char, &str).

Énoncé :

Écris un programme qui :

1. Déclare une variable name contenant ton prénom (immuable).


2. Déclare une variable age de type entier signé.


3. Déclare une variable pi de type f64.


4. Affiche ces valeurs avec println!.


5. Modifie age pour y ajouter 1 (passe la variable en mutable).




Documentation Rust à consulter :

Chapitre 3.1 : "Variables and Mutability" – https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html

Chapitre 3.2 : "Data Types" – https://doc.rust-lang.org/book/ch03-02-data-types.html


Questions sur les notions Rust :

1. Pourquoi les variables sont-elles immuables par défaut en Rust ?


2. Quelle est la différence entre &str et String ?


3. Que se passe-t-il si on essaie de modifier une variable non mutable ?



Questions de comparaison avec C :

1. Quelle est la différence de comportement entre une variable const en C et une variable immuable en Rust ?


2. En C, les chaînes sont des tableaux de char. En quoi la gestion des chaînes en Rust diffère-t-elle ?


3. Pourquoi Rust choisit-il de typer explicitement certaines valeurs alors que C peut inférer via promotion de types ?




---

Exercice 3 : Ownership et emprunts – Comprendre la propriété

Objectif :
Comprendre le concept fondamental d’ownership, comment les valeurs sont déplacées, et comment emprunter avec des références (&).

Énoncé :

Écris un programme qui :

1. Crée une variable s de type String.


2. Passe s à une fonction qui prend la propriété et l’affiche.


3. Observe que s n’est plus utilisable après l’appel.


4. Modifie le code pour que la fonction prenne une référence &s au lieu de s afin que la variable reste utilisable.




Documentation Rust à consulter :

Chapitre 4.1 : "What is Ownership?" – https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html

Chapitre 4.2 : "References and Borrowing" – https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html


Questions sur les notions Rust :

1. Que signifie « prendre la propriété » d’une valeur en Rust ?


2. Quelle différence entre un emprunt mutable et un emprunt immuable ?


3. Pourquoi Rust interdit-il d’avoir plusieurs emprunts mutables en même temps ?



Questions de comparaison avec C :

1. En C, passer un pointeur à une fonction ne transfère pas la propriété. Pourquoi Rust change-t-il cette logique ?


2. Quels problèmes classiques en C sont évités grâce à l’ownership de Rust ?


3. Quels sont les inconvénients potentiels de ce modèle par rapport à C ?



Exercice 4 : Structures de contrôle – if, loops, match

Objectif :
Savoir utiliser les principales structures de contrôle en Rust pour gérer la logique conditionnelle et les boucles.

Énoncé :

Écris un programme qui :

1. Demande à l’utilisateur de saisir un nombre (tu peux utiliser une valeur fixe au début pour simplifier).


2. Si le nombre est négatif, affiche "Nombre négatif".


3. Si le nombre est zéro, affiche "Zéro".


4. Si le nombre est positif, affiche "Nombre positif".


5. Utilise une boucle for pour afficher les nombres de 1 à 5.


6. Utilise un match pour afficher si un entier est pair, impair ou nul.




Documentation Rust à consulter :

Chapitre 3.5 : "Control Flow" – https://doc.rust-lang.org/book/ch03-05-control-flow.html

Chapitre 6 : "Enums and Pattern Matching" – https://doc.rust-lang.org/book/ch06-00-enums.html


Questions sur les notions Rust :

1. Quelle différence entre loop, while et for en Rust ?


2. Qu’apporte match par rapport à un switch en C ?


3. Pourquoi Rust exige-t-il que toutes les branches d’un match couvrent tous les cas possibles ?



Questions de comparaison avec C :

1. Comment les boucles for en Rust diffèrent-elles de celles en C (syntaxe et fonctionnement) ?


2. Quels avantages à avoir un match exhaustif par rapport au switch en C ?


3. En C, il est possible d’oublier un break dans un switch. Pourquoi Rust interdit-il le "fallthrough" implicite ?




---

Exercice 5 : Fonctions – Définition, paramètres, retour

Objectif :
Savoir définir et appeler des fonctions, avec et sans valeurs de retour, et comprendre l’expression implicite de retour.

Énoncé :

Écris un programme qui :

1. Définit une fonction double(x: i32) -> i32 qui retourne x * 2.


2. Définit une fonction print_message(msg: &str) qui affiche un message.


3. Appelle ces fonctions dans main.


4. Expérimente en retirant le ; à la fin d’une expression de retour pour voir la différence.




Documentation Rust à consulter :

Chapitre 3.3 : "Functions" – https://doc.rust-lang.org/book/ch03-03-how-functions-work.html


Questions sur les notions Rust :

1. Pourquoi les retours de fonction peuvent-ils être implicites en Rust ?


2. Quelle différence entre &str et String dans les paramètres de fonction ?


3. Pourquoi est-il recommandé de typer explicitement les paramètres et les retours, même si parfois Rust peut inférer ?



Questions de comparaison avec C :

1. Quelle différence de syntaxe entre une fonction Rust et une fonction C ?


2. En C, une fonction sans retour est void. Comment exprime-t-on cela en Rust ?


3. Quels avantages apporte l’absence de valeurs implicites comme 0 ou NULL dans le retour d’une fonction en Rust ?




---

Exercice 6 : Gestion d’erreurs – Result, Option, panic!

Objectif :
Comprendre la gestion sécurisée des erreurs avec Result et Option, et apprendre à utiliser panic! de façon contrôlée.

Énoncé :

Écris un programme qui :

1. Demande à l’utilisateur de saisir un nombre (utilise une chaîne fixe pour simplifier).


2. Convertit la chaîne en i32 avec .parse::<i32>().


3. Utilise un match sur le Result retourné pour afficher soit "Nombre valide" soit "Erreur de conversion".


4. Écris une fonction qui retourne Option<i32> si un calcul est possible, ou None sinon.


5. Utilise panic! volontairement pour voir le message d’erreur et la pile d’exécution.




Documentation Rust à consulter :

Chapitre 9.1 : "Unrecoverable Errors with panic!" – https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html

Chapitre 9.2 : "Recoverable Errors with Result" – https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html

Chapitre 6.1 : "Option Enum" – https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html


Questions sur les notions Rust :

1. Quelle différence entre Option et Result ?


2. Pourquoi utiliser match ou if let pour gérer un Result ?


3. Dans quel cas l’usage de panic! est-il acceptable ?



Questions de comparaison avec C :

1. En C, comment gère-t-on généralement les erreurs et en quoi Rust diffère-t-il ?


2. Pourquoi Rust préfère-t-il des types explicites pour représenter l’absence de valeur plutôt qu’un NULL ?


3. Quels risques du C sont éliminés par le système d’erreurs de Rust ?


Parfait, on termine avec l’Exercice 10, qui va rassembler toutes les briques qu’on a vues pour créer un générateur de mots de passe complet.


---

Exercice 10 : Projet final – Générateur de mots de passe configurable

Objectif :
Assembler toutes les notions précédentes pour créer un programme Rust complet, structuré, modulaire et robuste, qui génère des mots de passe selon les paramètres choisis par l’utilisateur.

Énoncé :

Crée un projet cargo new password_gen.

Organisation du code :

main.rs : gestion des arguments et du flux principal.

password.rs : génération des mots de passe.

utils.rs : fonctions utilitaires (lecture entrée utilisateur, validations).


Fonctionnalités attendues :

1. L’utilisateur peut choisir la longueur du mot de passe (par argument CLI ou saisie clavier).


2. L’utilisateur peut activer/désactiver l’inclusion de chiffres, lettres majuscules, lettres minuscules et caractères spéciaux.


3. Utilisation de la crate rand pour générer les caractères aléatoires.


4. Si l’utilisateur ne fournit aucun argument, proposer des valeurs par défaut.


5. Sauvegarder le mot de passe généré dans un fichier passwords.txt.


6. Afficher le mot de passe à l’écran.




Documentation Rust à consulter :

Chapitre 12.1 : "Accepting Command Line Arguments" – https://doc.rust-lang.org/book/ch12-01-accepting-command-line-arguments.html

Chapitre 8.1 : "Vectors" – https://doc.rust-lang.org/book/ch08-01-vectors.html

Chapitre 8.3 : "Hash Maps" – https://doc.rust-lang.org/book/ch08-03-hash-maps.html

Documentation rand crate – https://docs.rs/rand/latest/rand/


Questions sur les notions Rust :

1. Pourquoi utiliser Vec<char> pour stocker le pool de caractères possibles ?


2. Quelle est la différence entre lire un argument CLI et lire une entrée utilisateur avec stdin() ?


3. Comment gérer proprement les erreurs lors de l’ouverture et de l’écriture dans un fichier ?



Questions de comparaison avec C :

1. En C, comment implémenterais-tu la génération de caractères aléatoires et la lecture d’arguments ?


2. Quels avantages la crate rand apporte-t-elle par rapport à rand() de <stdlib.h> en C ?


3. Pourquoi Rust impose-t-il des retours Result explicites pour les opérations à risque plutôt que de laisser l’utilisateur vérifier manuellement errno comme en C ?




---

Ce dernier exercice devrait te pousser à :

Utiliser modules et traits (pour la logique et la réutilisabilité).

Manipuler ownership et emprunts proprement (ex. pour passer la config du programme).

Exploiter gestion d’erreurs avec Result et Option.

Faire de l’I/O et manipuler des collections.


💡 Astuce de progression :
Commence par un générateur minimal (longueur fixe, juste lettres minuscules), puis ajoute les options une par une, en testant après chaque étape.






