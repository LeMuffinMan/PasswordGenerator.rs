Exercices generated by Chat-GPT5 study, with this prompt built with Claude :

Tu es un mentor Rust exp√©riment√©. Je d√©bute en Rust mais j'ai une solide base en C. Je veux que tu me cr√©√©s une s√©rie d'exercices progressifs menant √† la cr√©ation d'un g√©n√©rateur de mots de passe.

Format demand√© pour chaque exercice :

Exercice N : [Titre descriptif]

Objectif : [Description claire de ce qu'on va apprendre]

√ânonc√© : [Description d√©taill√©e de l'exercice √† r√©aliser]

Documentation Rust √† consulter :

Chapitre X.Y : [Titre] - [URL vers la doc officielle]

Chapitre X.Z : [Titre] - [URL vers la doc officielle]


Questions sur les notions Rust :

1. [Question sur le concept Rust principal de l'exercice]


2. [Question sur un d√©tail technique important]


3. [Question sur les bonnes pratiques Rust]



Questions de comparaison avec C :

1. [Comment cette fonctionnalit√© diff√®re-t-elle de C ?]


2. [Quels avantages/inconv√©nients par rapport √† l'√©quivalent en C ?]


3. [Pourquoi Rust a-t-il fait ce choix de design diff√©rent ?]



Progression souhait√©e :

1. Bases : Hello World, variables, types de base


2. Ownership : Propri√©t√©, emprunt, dur√©e de vie


3. Structures de contr√¥le : if/else, loops, match


4. Fonctions : d√©finition, param√®tres, valeurs de retour


5. Structures de donn√©es : struct, enum, Vec, HashMap


6. Gestion d'erreurs : Result, Option, panic


7. Traits et g√©n√©riques : d√©finition et utilisation


8. Modules et crates : organisation du code


9. I/O et fichiers : lecture/√©criture, arguments ligne de commande


10. G√©n√©rateur final : assemblage pour cr√©er le g√©n√©rateur de mots de passe



Contraintes importantes :

Chaque exercice doit r√©f√©rencer la documentation officielle Rust (https://doc.rust-lang.org/book/)

Les exercices doivent √™tre pratiques et construire vers l'objectif final

Inclure syst√©matiquement des comparaisons avec C pour leverager mes connaissances existantes

Les questions doivent me faire r√©fl√©chir sur les concepts, pas juste recopier

Commencer simple et augmenter progressivement la complexit√©



Exercice 1 : Premier pas avec Rust ‚Äì Hello World

Objectif :
D√©couvrir la structure minimale d‚Äôun programme Rust, apprendre √† compiler et ex√©cuter du code, et comprendre la fonction main.

√ânonc√© :

Cr√©e un nouveau projet Rust avec cargo new hello_rust.

Dans le fichier main.rs, √©cris un programme qui affiche exactement :

Hello, Rust!

Compile avec cargo build et ex√©cute avec cargo run.

Modifie le texte affich√© pour inclure ton pr√©nom.


Documentation Rust √† consulter :

Chapitre 1.1 : "Installation" ‚Äì https://doc.rust-lang.org/book/ch01-01-installation.html

Chapitre 1.2 : "Hello, World!" ‚Äì https://doc.rust-lang.org/book/ch01-02-hello-world.html


Questions sur les notions Rust :

1. Pourquoi la fonction main est-elle sp√©ciale en Rust ?


2. Quelle est la diff√©rence entre println! et print! ?


3. Pourquoi println! est-il un macro et non une fonction classique ?



Questions de comparaison avec C :

1. Comment la fonction main en Rust diff√®re-t-elle de celle en C (signature, retour) ?


2. Quels avantages y a-t-il √† utiliser cargo plut√¥t que gcc pour un projet simple ?


3. Pourquoi Rust impose-t-il une structure stricte de projet d√®s le d√©part ?




---

Exercice 2 : Variables et types de base

Objectif :
Apprendre √† d√©clarer des variables, comprendre l‚Äôimmuabilit√© par d√©faut, et manipuler les types simples (i32, f64, bool, char, &str).

√ânonc√© :

√âcris un programme qui :

1. D√©clare une variable name contenant ton pr√©nom (immuable).


2. D√©clare une variable age de type entier sign√©.


3. D√©clare une variable pi de type f64.


4. Affiche ces valeurs avec println!.


5. Modifie age pour y ajouter 1 (passe la variable en mutable).




Documentation Rust √† consulter :

Chapitre 3.1 : "Variables and Mutability" ‚Äì https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html

Chapitre 3.2 : "Data Types" ‚Äì https://doc.rust-lang.org/book/ch03-02-data-types.html


Questions sur les notions Rust :

1. Pourquoi les variables sont-elles immuables par d√©faut en Rust ?


2. Quelle est la diff√©rence entre &str et String ?


3. Que se passe-t-il si on essaie de modifier une variable non mutable ?



Questions de comparaison avec C :

1. Quelle est la diff√©rence de comportement entre une variable const en C et une variable immuable en Rust ?


2. En C, les cha√Ænes sont des tableaux de char. En quoi la gestion des cha√Ænes en Rust diff√®re-t-elle ?


3. Pourquoi Rust choisit-il de typer explicitement certaines valeurs alors que C peut inf√©rer via promotion de types ?




---

Exercice 3 : Ownership et emprunts ‚Äì Comprendre la propri√©t√©

Objectif :
Comprendre le concept fondamental d‚Äôownership, comment les valeurs sont d√©plac√©es, et comment emprunter avec des r√©f√©rences (&).

√ânonc√© :

√âcris un programme qui :

1. Cr√©e une variable s de type String.


2. Passe s √† une fonction qui prend la propri√©t√© et l‚Äôaffiche.


3. Observe que s n‚Äôest plus utilisable apr√®s l‚Äôappel.


4. Modifie le code pour que la fonction prenne une r√©f√©rence &s au lieu de s afin que la variable reste utilisable.




Documentation Rust √† consulter :

Chapitre 4.1 : "What is Ownership?" ‚Äì https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html

Chapitre 4.2 : "References and Borrowing" ‚Äì https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html


Questions sur les notions Rust :

1. Que signifie ¬´ prendre la propri√©t√© ¬ª d‚Äôune valeur en Rust ?


2. Quelle diff√©rence entre un emprunt mutable et un emprunt immuable ?


3. Pourquoi Rust interdit-il d‚Äôavoir plusieurs emprunts mutables en m√™me temps ?



Questions de comparaison avec C :

1. En C, passer un pointeur √† une fonction ne transf√®re pas la propri√©t√©. Pourquoi Rust change-t-il cette logique ?


2. Quels probl√®mes classiques en C sont √©vit√©s gr√¢ce √† l‚Äôownership de Rust ?


3. Quels sont les inconv√©nients potentiels de ce mod√®le par rapport √† C ?



Exercice 4 : Structures de contr√¥le ‚Äì if, loops, match

Objectif :
Savoir utiliser les principales structures de contr√¥le en Rust pour g√©rer la logique conditionnelle et les boucles.

√ânonc√© :

√âcris un programme qui :

1. Demande √† l‚Äôutilisateur de saisir un nombre (tu peux utiliser une valeur fixe au d√©but pour simplifier).


2. Si le nombre est n√©gatif, affiche "Nombre n√©gatif".


3. Si le nombre est z√©ro, affiche "Z√©ro".


4. Si le nombre est positif, affiche "Nombre positif".


5. Utilise une boucle for pour afficher les nombres de 1 √† 5.


6. Utilise un match pour afficher si un entier est pair, impair ou nul.




Documentation Rust √† consulter :

Chapitre 3.5 : "Control Flow" ‚Äì https://doc.rust-lang.org/book/ch03-05-control-flow.html

Chapitre 6 : "Enums and Pattern Matching" ‚Äì https://doc.rust-lang.org/book/ch06-00-enums.html


Questions sur les notions Rust :

1. Quelle diff√©rence entre loop, while et for en Rust ?


2. Qu‚Äôapporte match par rapport √† un switch en C ?


3. Pourquoi Rust exige-t-il que toutes les branches d‚Äôun match couvrent tous les cas possibles ?



Questions de comparaison avec C :

1. Comment les boucles for en Rust diff√®rent-elles de celles en C (syntaxe et fonctionnement) ?


2. Quels avantages √† avoir un match exhaustif par rapport au switch en C ?


3. En C, il est possible d‚Äôoublier un break dans un switch. Pourquoi Rust interdit-il le "fallthrough" implicite ?




---

Exercice 5 : Fonctions ‚Äì D√©finition, param√®tres, retour

Objectif :
Savoir d√©finir et appeler des fonctions, avec et sans valeurs de retour, et comprendre l‚Äôexpression implicite de retour.

√ânonc√© :

√âcris un programme qui :

1. D√©finit une fonction double(x: i32) -> i32 qui retourne x * 2.


2. D√©finit une fonction print_message(msg: &str) qui affiche un message.


3. Appelle ces fonctions dans main.


4. Exp√©rimente en retirant le ; √† la fin d‚Äôune expression de retour pour voir la diff√©rence.




Documentation Rust √† consulter :

Chapitre 3.3 : "Functions" ‚Äì https://doc.rust-lang.org/book/ch03-03-how-functions-work.html


Questions sur les notions Rust :

1. Pourquoi les retours de fonction peuvent-ils √™tre implicites en Rust ?


2. Quelle diff√©rence entre &str et String dans les param√®tres de fonction ?


3. Pourquoi est-il recommand√© de typer explicitement les param√®tres et les retours, m√™me si parfois Rust peut inf√©rer ?



Questions de comparaison avec C :

1. Quelle diff√©rence de syntaxe entre une fonction Rust et une fonction C ?


2. En C, une fonction sans retour est void. Comment exprime-t-on cela en Rust ?


3. Quels avantages apporte l‚Äôabsence de valeurs implicites comme 0 ou NULL dans le retour d‚Äôune fonction en Rust ?




---

Exercice 6 : Gestion d‚Äôerreurs ‚Äì Result, Option, panic!

Objectif :
Comprendre la gestion s√©curis√©e des erreurs avec Result et Option, et apprendre √† utiliser panic! de fa√ßon contr√¥l√©e.

√ânonc√© :

√âcris un programme qui :

1. Demande √† l‚Äôutilisateur de saisir un nombre (utilise une cha√Æne fixe pour simplifier).


2. Convertit la cha√Æne en i32 avec .parse::<i32>().


3. Utilise un match sur le Result retourn√© pour afficher soit "Nombre valide" soit "Erreur de conversion".


4. √âcris une fonction qui retourne Option<i32> si un calcul est possible, ou None sinon.


5. Utilise panic! volontairement pour voir le message d‚Äôerreur et la pile d‚Äôex√©cution.




Documentation Rust √† consulter :

Chapitre 9.1 : "Unrecoverable Errors with panic!" ‚Äì https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html

Chapitre 9.2 : "Recoverable Errors with Result" ‚Äì https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html

Chapitre 6.1 : "Option Enum" ‚Äì https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html


Questions sur les notions Rust :

1. Quelle diff√©rence entre Option et Result ?


2. Pourquoi utiliser match ou if let pour g√©rer un Result ?


3. Dans quel cas l‚Äôusage de panic! est-il acceptable ?



Questions de comparaison avec C :

1. En C, comment g√®re-t-on g√©n√©ralement les erreurs et en quoi Rust diff√®re-t-il ?


2. Pourquoi Rust pr√©f√®re-t-il des types explicites pour repr√©senter l‚Äôabsence de valeur plut√¥t qu‚Äôun NULL ?


3. Quels risques du C sont √©limin√©s par le syst√®me d‚Äôerreurs de Rust ?


Parfait, on termine avec l‚ÄôExercice 10, qui va rassembler toutes les briques qu‚Äôon a vues pour cr√©er un g√©n√©rateur de mots de passe complet.


---

Exercice 10 : Projet final ‚Äì G√©n√©rateur de mots de passe configurable

Objectif :
Assembler toutes les notions pr√©c√©dentes pour cr√©er un programme Rust complet, structur√©, modulaire et robuste, qui g√©n√®re des mots de passe selon les param√®tres choisis par l‚Äôutilisateur.

√ânonc√© :

Cr√©e un projet cargo new password_gen.

Organisation du code :

main.rs : gestion des arguments et du flux principal.

password.rs : g√©n√©ration des mots de passe.

utils.rs : fonctions utilitaires (lecture entr√©e utilisateur, validations).


Fonctionnalit√©s attendues :

1. L‚Äôutilisateur peut choisir la longueur du mot de passe (par argument CLI ou saisie clavier).


2. L‚Äôutilisateur peut activer/d√©sactiver l‚Äôinclusion de chiffres, lettres majuscules, lettres minuscules et caract√®res sp√©ciaux.


3. Utilisation de la crate rand pour g√©n√©rer les caract√®res al√©atoires.


4. Si l‚Äôutilisateur ne fournit aucun argument, proposer des valeurs par d√©faut.


5. Sauvegarder le mot de passe g√©n√©r√© dans un fichier passwords.txt.


6. Afficher le mot de passe √† l‚Äô√©cran.




Documentation Rust √† consulter :

Chapitre 12.1 : "Accepting Command Line Arguments" ‚Äì https://doc.rust-lang.org/book/ch12-01-accepting-command-line-arguments.html

Chapitre 8.1 : "Vectors" ‚Äì https://doc.rust-lang.org/book/ch08-01-vectors.html

Chapitre 8.3 : "Hash Maps" ‚Äì https://doc.rust-lang.org/book/ch08-03-hash-maps.html

Documentation rand crate ‚Äì https://docs.rs/rand/latest/rand/


Questions sur les notions Rust :

1. Pourquoi utiliser Vec<char> pour stocker le pool de caract√®res possibles ?


2. Quelle est la diff√©rence entre lire un argument CLI et lire une entr√©e utilisateur avec stdin() ?


3. Comment g√©rer proprement les erreurs lors de l‚Äôouverture et de l‚Äô√©criture dans un fichier ?



Questions de comparaison avec C :

1. En C, comment impl√©menterais-tu la g√©n√©ration de caract√®res al√©atoires et la lecture d‚Äôarguments ?


2. Quels avantages la crate rand apporte-t-elle par rapport √† rand() de <stdlib.h> en C ?


3. Pourquoi Rust impose-t-il des retours Result explicites pour les op√©rations √† risque plut√¥t que de laisser l‚Äôutilisateur v√©rifier manuellement errno comme en C ?




---

Ce dernier exercice devrait te pousser √† :

Utiliser modules et traits (pour la logique et la r√©utilisabilit√©).

Manipuler ownership et emprunts proprement (ex. pour passer la config du programme).

Exploiter gestion d‚Äôerreurs avec Result et Option.

Faire de l‚ÄôI/O et manipuler des collections.


üí° Astuce de progression :
Commence par un g√©n√©rateur minimal (longueur fixe, juste lettres minuscules), puis ajoute les options une par une, en testant apr√®s chaque √©tape.






